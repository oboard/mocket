// Generated using `moon info`, DON'T EDIT IT
package "oboard/mocket"

import(
  "illusory0x0/native"
  "moonbitlang/core/buffer"
)

// Values
pub fn __ws_emit(@native.CStr, @native.CStr, @native.CStr) -> Unit

pub fn async_run(async () -> Unit noraise) -> Unit

pub fn cookie_to_string(Array[CookieItem]) -> String

pub async fn execute_middlewares(Array[(String, async (MocketEvent, async () -> &Responder noraise) -> &Responder noraise)], MocketEvent, async (MocketEvent) -> &Responder noraise) -> &Responder noraise

pub fn form_encode(Map[String, String]) -> String

pub async fn handle_not_found(MocketEvent) -> &Responder noraise

pub fn html(&Show) -> &Responder

pub fn new(base_path? : String) -> Mocket

pub fn parse_cookie(StringView) -> Map[String, CookieItem]

pub fn parse_form_data(BytesView) -> Map[String, String]

pub fn parse_multipart(BytesView, String) -> Map[String, MultipartFormValue]

pub fn register_ws_handler(Mocket, Int) -> Unit

pub fn serve_ffi(Mocket, port~ : Int) -> Unit

pub async fn[T, E : Error] suspend(((T) -> Unit, (E) -> Unit) -> Unit) -> T raise E

pub fn text(&Show) -> &Responder

pub fn url_decode(BytesView) -> String

pub fn url_encode(String) -> String

pub fn ws_pong(String) -> Unit

pub fn ws_publish(String, String) -> Unit

pub fn ws_send(String, String) -> Unit

pub fn ws_send_bytes(String, Bytes) -> Unit

pub fn ws_subscribe(String, String) -> Unit

pub fn ws_unsubscribe(String, String) -> Unit

// Errors
pub suberror ExecError
pub impl Show for ExecError

pub suberror IOError
pub impl Show for IOError

pub suberror NetworkError
pub impl Show for NetworkError

// Types and methods
pub(all) struct CookieItem {
  name : String
  value : String
  max_age : Int?
  path : String?
  domain : String?
  secure : Bool?
  http_only : Bool?
  same_site : SameSiteOption?
}
pub impl Eq for CookieItem
pub impl Show for CookieItem

type Html
pub impl Responder for Html

pub(all) struct HttpRequest {
  http_method : String
  url : String
  headers : Map[StringView, StringView]
  mut raw_body : Bytes
}
pub fn[T : BodyReader] HttpRequest::body(Self) -> T raise
pub fn HttpRequest::get_cookie(Self, String) -> CookieItem?
pub impl Responder for HttpRequest

#external
pub type HttpRequestInternal
pub fn HttpRequestInternal::on_complete(Self, FuncRef[() -> Unit]) -> Unit
pub fn HttpRequestInternal::on_headers(Self, FuncRef[(@native.CStr) -> Unit]) -> Unit

pub(all) struct HttpResponse {
  mut status_code : StatusCode
  headers : Map[StringView, StringView]
  cookies : Map[String, CookieItem]
  mut raw_body : Bytes
}
pub fn HttpResponse::body(Self, &Responder) -> Self
pub fn HttpResponse::delete_cookie(Self, String) -> Unit
pub fn HttpResponse::json(Self, &ToJson) -> Self
pub fn HttpResponse::new(StatusCode, headers? : Map[StringView, StringView], cookies? : Map[String, CookieItem], raw_body? : Bytes) -> Self
pub fn HttpResponse::set_cookie(Self, String, String, max_age? : Int, path? : String, domain? : String, secure? : Bool, http_only? : Bool, same_site? : SameSiteOption) -> Unit
pub fn HttpResponse::to_responder(Self) -> &Responder
pub impl Responder for HttpResponse

#external
pub type HttpResponseInternal

#external
pub type HttpServerInternal

#alias(T)
pub(all) struct Mocket {
  base_path : String
  mappings : Map[(String, String), async (MocketEvent) -> &Responder noraise]
  middlewares : Array[(String, async (MocketEvent, async () -> &Responder noraise) -> &Responder noraise)]
  static_routes : Map[String, Map[String, async (MocketEvent) -> &Responder noraise]]
  dynamic_routes : Map[String, Array[(String, async (MocketEvent) -> &Responder noraise)]]
  ws_static_routes : Map[String, (WebSocketEvent) -> Unit]
  ws_dynamic_routes : Array[(String, (WebSocketEvent) -> Unit)]
  ws_clients : Map[String, Unit]
  ws_channels : Map[String, Map[String, Unit]]
  ws_client_port : Map[String, Int]
}
pub fn Mocket::all(Self, String, async (MocketEvent) -> &Responder noraise) -> Unit
pub fn Mocket::connect(Self, String, async (MocketEvent) -> &Responder noraise) -> Unit
pub fn Mocket::delete(Self, String, async (MocketEvent) -> &Responder noraise) -> Unit
pub fn Mocket::get(Self, String, async (MocketEvent) -> &Responder noraise) -> Unit
pub fn Mocket::group(Self, String, (Self) -> Unit) -> Unit
pub fn Mocket::head(Self, String, async (MocketEvent) -> &Responder noraise) -> Unit
pub fn Mocket::on(Self, String, String, async (MocketEvent) -> &Responder noraise) -> Unit
pub fn Mocket::options(Self, String, async (MocketEvent) -> &Responder noraise) -> Unit
pub fn Mocket::patch(Self, String, async (MocketEvent) -> &Responder noraise) -> Unit
pub fn Mocket::post(Self, String, async (MocketEvent) -> &Responder noraise) -> Unit
pub fn Mocket::put(Self, String, async (MocketEvent) -> &Responder noraise) -> Unit
pub fn Mocket::serve(Self, port~ : Int) -> Unit
pub fn Mocket::static_assets(Self, String, &ServeStaticProvider) -> Unit
pub fn Mocket::trace(Self, String, async (MocketEvent) -> &Responder noraise) -> Unit
pub fn Mocket::use_middleware(Self, async (MocketEvent, async () -> &Responder noraise) -> &Responder noraise, base_path? : String) -> Unit
pub fn Mocket::ws(Self, String, (WebSocketEvent) -> Unit) -> Unit

pub(all) struct MocketEvent {
  req : HttpRequest
  res : HttpResponse
  params : Map[String, StringView]
}

pub(all) struct MultipartFormValue {
  filename : String?
  content_type : String?
  data : BytesView
}

pub(all) enum SameSiteOption {
  Lax
  Strict
  SameSiteNone
}
pub impl Eq for SameSiteOption
pub impl Show for SameSiteOption
pub impl ToJson for SameSiteOption

pub(all) struct StaticAssetMeta {
  asset_type : String?
  etag : String?
  mtime : Int64?
  path : String?
  size : Int64?
  encoding : String?
}
pub fn StaticAssetMeta::new(asset_type? : String, etag? : String, mtime? : Int64, path? : String, size? : Int64, encoding? : String) -> Self

pub(all) enum StatusCode {
  Continue
  SwitchingProtocols
  Processing
  EarlyHints
  OK
  Created
  Accepted
  NonAuthoritativeInfo
  NoContent
  ResetContent
  PartialContent
  MultiStatus
  AlreadyReported
  IMUsed
  MultipleChoices
  MovedPermanently
  Found
  SeeOther
  NotModified
  UseProxy
  TemporaryRedirect
  PermanentRedirect
  BadRequest
  Unauthorized
  PaymentRequired
  Forbidden
  NotFound
  MethodNotAllowed
  NotAcceptable
  ProxyAuthRequired
  RequestTimeout
  Conflict
  Gone
  LengthRequired
  PreconditionFailed
  RequestEntityTooLarge
  RequestUriTooLong
  UnsupportedMediaType
  RequestedRangeNotSatisfiable
  ExpectationFailed
  Teapot
  MisdirectedRequest
  UnprocessableEntity
  Locked
  FailedDependency
  TooEarly
  UpgradeRequired
  PreconditionRequired
  TooManyRequests
  RequestHeaderFieldsTooLarge
  UnavailableForLegalReasons
  InternalServerError
  NotImplemented
  BadGateway
  ServiceUnavailable
  GatewayTimeout
  HttpVersionNotSupported
  VariantAlsoNegotiates
  InsufficientStorage
  LoopDetected
  NotExtended
  NetworkAuthenticationRequired
  Custom(Int)
}
pub fn StatusCode::from_int(Int) -> Self
pub fn StatusCode::to_int(Self) -> Int
pub impl Show for StatusCode
pub impl ToJson for StatusCode

pub enum WebSocketAggregatedMessage {
  Text(String)
  Binary(Bytes)
  Ping
}

pub enum WebSocketEvent {
  Open(WebSocketPeer)
  Message(WebSocketPeer, WebSocketAggregatedMessage)
  Close(WebSocketPeer)
}

pub(all) struct WebSocketPeer {
  connection_id : String
  mut subscribed_channels : Array[String]
}
pub fn WebSocketPeer::binary(Self, Bytes) -> Unit
pub fn WebSocketPeer::pong(Self) -> Unit
pub fn WebSocketPeer::publish(String, String) -> Unit
pub fn WebSocketPeer::subscribe(Self, String) -> Unit
pub fn WebSocketPeer::text(Self, String) -> Unit
pub fn WebSocketPeer::to_string(Self) -> String
pub fn WebSocketPeer::unsubscribe(Self, String) -> Unit

// Type aliases
pub type HttpHandler = async (MocketEvent) -> &Responder noraise

pub type Middleware = async (MocketEvent, async () -> &Responder noraise) -> &Responder noraise

pub type WebSocketHandler = (WebSocketEvent) -> Unit

// Traits
pub(open) trait BodyReader {
  from_request(HttpRequest) -> Self raise
}
pub impl BodyReader for String
pub impl BodyReader for FixedArray[Byte]
pub impl BodyReader for Bytes
pub impl BodyReader for Array[Byte]
pub impl BodyReader for Json

pub(open) trait Responder {
  options(Self, HttpResponse) -> Unit
  output(Self, @buffer.Buffer) -> Unit
}
pub impl Responder for String
pub impl Responder for Bytes
pub impl Responder for Json
pub impl Responder for &ToJson
pub impl Responder for StringView

pub(open) trait ServeStaticProvider {
  get_meta(Self, String) -> StaticAssetMeta?
  get_contents(Self, String) -> &Responder
  get_type(Self, String) -> String?
  get_encodings(Self) -> Map[String, String]
  get_index_names(Self) -> Array[String]
  get_fallthrough(Self) -> Bool
}

