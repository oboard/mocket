// Generated using `moon info`, DON'T EDIT IT
package "oboard/mocket/lib"

import(
  "moonbitlang/core/builtin"
  "rami3l/js-ffi/js"
)

// Values
fn createServer((HttpRequestInternal, HttpResponseInternal, () -> Unit) -> Unit, Int) -> Unit

fn html(String) -> Json

fn json(Json) -> Json

fn new(base_path? : String, logger? : Logger) -> Mocket

fn new_debug_logger() -> Logger

fn new_logger(enabled? : Bool, level? : LogLevel) -> Logger

fn new_production_logger() -> Logger

fn run(async () -> Unit) -> Unit

async fn[T, E : Error] suspend(((T) -> Unit, (E) -> Unit) -> Unit) -> T raise E

fn text(String) -> Json

// Errors
pub suberror ExecError
impl Show for ExecError

pub suberror IOError
impl Show for IOError

pub suberror NetworkError
impl Show for NetworkError

// Types and methods
pub struct HttpEvent {
  req : HttpRequest
  res : HttpResponse
  mut params : Map[String, String]
}

pub struct HttpRequest {
  method_ : String
  url : String
  headers : Map[String, String]
  mut body : String
}

#external
pub type HttpRequestInternal
fn HttpRequestInternal::headers(Self) -> @js.Object
fn HttpRequestInternal::on(Self, String, (@js.Value) -> Unit) -> Unit
fn HttpRequestInternal::req_method(Self) -> String
fn HttpRequestInternal::url(Self) -> String

pub(all) struct HttpResponse {
  mut status_code : Int
  headers : Map[String, String]
}

#external
pub type HttpResponseInternal
fn HttpResponseInternal::end(Self, String) -> Unit
fn HttpResponseInternal::statusCode(Self) -> Int
fn HttpResponseInternal::url(Self) -> String
fn HttpResponseInternal::write_head(Self, Int, @js.Value) -> Unit

pub enum LogLevel {
  Debug
  Info
  Warn
  Error
}

pub struct Logger {
  enabled : Bool
  level : LogLevel
}
fn Logger::debug(Self, () -> String) -> Unit
fn Logger::debug_str(Self, String) -> Unit
fn Logger::error(Self, () -> String) -> Unit
fn Logger::info(Self, () -> String) -> Unit
fn Logger::route_added(Self, String) -> Unit
fn Logger::route_created(Self, String) -> Unit
fn Logger::route_dynamic(Self, String, String) -> Unit
fn Logger::route_found(Self, String, String) -> Unit
fn Logger::route_lookup(Self, String, String) -> Unit
fn Logger::route_merge_existing(Self, String) -> Unit
fn Logger::route_merge_new(Self, String) -> Unit
fn Logger::route_not_found(Self, String) -> Unit
fn Logger::route_register(Self, String, String) -> Unit
fn Logger::route_static(Self, String, String) -> Unit
fn Logger::routes_available(Self, Array[String]) -> Unit
fn Logger::warn(Self, () -> String) -> Unit

pub(all) struct Mocket {
  base_path : String
  mappings : Map[(String, String), async (HttpEvent) -> Json]
  middlewares : Array[(String, async (HttpEvent) -> Unit)]
  static_routes : Map[String, Map[String, async (HttpEvent) -> Json]]
  dynamic_routes : Map[String, Array[(String, async (HttpEvent) -> Json)]]
  logger : Logger
}
fn Mocket::all(Self, String, async (HttpEvent) -> Json) -> Unit
fn Mocket::connect(Self, String, async (HttpEvent) -> Json) -> Unit
fn Mocket::delete(Self, String, async (HttpEvent) -> Json) -> Unit
fn Mocket::get(Self, String, async (HttpEvent) -> Json) -> Unit
fn Mocket::group(Self, String, (Self) -> Unit) -> Unit
fn Mocket::head(Self, String, async (HttpEvent) -> Json) -> Unit
fn Mocket::on(Self, String, String, async (HttpEvent) -> Json) -> Unit
fn Mocket::options(Self, String, async (HttpEvent) -> Json) -> Unit
fn Mocket::patch(Self, String, async (HttpEvent) -> Json) -> Unit
fn Mocket::post(Self, String, async (HttpEvent) -> Json) -> Unit
fn Mocket::put(Self, String, async (HttpEvent) -> Json) -> Unit
fn Mocket::serve(Self, port~ : Int) -> Unit
fn Mocket::trace(Self, String, async (HttpEvent) -> Json) -> Unit
fn Mocket::use_middleware(Self, async (HttpEvent) -> Unit, base_path? : String) -> Unit

pub struct URL {
  protocol : String?
  host : String?
  port : Int?
  path : String
  query : Map[String, String]?
  fragment : String?
}
fn URL::output(Self, Logger) -> Unit
fn URL::parse(String) -> Self
fn URL::to_string(Self) -> String
impl Show for URL

// Type aliases
pub typealias Mocket as T

// Traits

